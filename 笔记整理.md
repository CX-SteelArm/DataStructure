笔记整理
==============
本文档是一些前端知识点的整理版本

# 目录
-------------

<details>
  <summary><b>点击打开目录</b></summary>

  - [前端基础](#前端基础)
  - [数据结构](#数据结构)
  - [网络](#计算机网络)

</details>

## 前端基础

-------------

1. CSS三栏布局方法 / 两栏左边固定右边自适应
* position: absolute定位，比较机械
* table/table-cell布局
* 浮动布局
* flex布局（flex有哪些属性，怎么用的）
* grid布局（grid常用属性有哪些，怎么用的）

2. CSS垂直居中方法
* height & line-height
* position + translate方法
* table-cell / inline-block自动居中
* flex两种方法
* writing-mode方法

3. CSS双栏等高布局方法
* position + margin负值模拟
* table/table-cell布局
* flex布局

4. CSS权值
#: 100
.: 10
tag: 1
继承: <1

4. Web语义化的理解
利于SEO，利于阅读网页信息，主要包含两部分：HTML语义化和CSS语义化
* HTML语义化包含让正确的标签做正确的事情、页面内容结构化、利于爬虫标记和SEO  
header, hgroup, footer, aside, nav, article, section等H5标签
* CSS语义化包含class和ID命名的语义，选择器名称是文档部件表达的意思或者在文中的位置，而不是样式相关。

5. 常见的14种HTML状态码

|状态码|标识|说明|
|:--:|:--:|:--:|
|200|OK|请求正常处理完毕|
|204|No Content|请求成功处理，没有实体的主体返回|
|206|Partial Content|GET范围请求已成功处理|
|301|Moved Permanently|永久重定向，资源已永久分配新URL|
|302|Found|临时重定向，资源已临时分配新URI|
|303|See Other|临时重定向，期望使用GET定向获取|
|304|Not Modified|配合If Modified Since 和 LastModify等使用的属性，和重定向没有半毛钱关系|
|307|Temporary Redirect|临时重定向，POST不会变成GET|
|400|Bad Request|请求报文语法错误或参数错误|
|401|Unauthorized|需要通过HTTP认证，或认证失败|
|404|Not Found|无法找到请求资源，服务器无理由拒绝|
|500|Internal Server Error|服务器故障或Web应用故障|
|506|Service Unavailable|服务器超负载或停机维护|

6. HTML报文头部以及消息报头有哪些常见值？什么意思？
请求头：
```
Accept  */*
Accept-Encoding gzip, deflate, br
Accept-Language zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Connection  keep-alive
Cookie  _uab_collina=15299169869571128…1632033F343C206B460BFAA9D4C49
Host  g.alicdn.com
Referer https://login.taobao.com/membe…3060e4575e98eb5293fa4adf49af4c
User-Agent Mozilla/5.0 (Windows NT 10.0; …) Gecko/20100101 Firefox/62.0
```
响应头：
```
access-control-allow-origin *
age 2583
cache-control max-age=2592000,s-maxage=3600
content-encoding  gzip
content-length  121629
content-md5 wXF/pQ0O55hPi21+qfDWYw==
content-type  application/javascript
date  Sun, 21 Oct 2018 13:17:02 GMT
server  Tengine
```

7. html cache类型有哪些？
* cache的优先级：`service worker`, `memory cache`, `disk cache`, network
* `memory cache`忽略html头中的设定，每次都会缓存，优先被命中，而且资源不返回状态码。
* `Cache-control`: no-store是一个例外情况，`memory cache`及`disk cache`不会缓存任何内容，一般关闭页面Tab后memory和cache失效。
* `disk cache` 分为**强缓存**和**协商缓存**
* 强缓存：关键字为`Cache-control（HTTP1.1）`,`Expires` & `Pragma: no-cache (HTTP1.0)`, `Cache-control`的优先级较高
* `Cache-control` 有`max-age`(单位秒), `must-revalidate`, `no-cache`(缓存内容但是不使用), `no-store`(不缓存内容), `private`(默认值，客户端缓存，代理服务器不缓存), `public`(客户端和代理服务器都缓存)等选项。
* 协商缓存：强缓存失效之后使用的缓存机制，无法节约请求数量，如果服务器返回304状态码，则节省了数据量，效果不如强缓存。
两对值：
服务器：`Last-Modified` 客户端：`If-Modified-Since`
服务器：`Etag` 客户端：`If-None-Match` （这一组优先级较高）
* 缓存的应用：

  1. 对于长期不变的资源，可以设置`Cache-control: max-age=360000` 很大的数字；
  2. 对于经常变动的资源，比如微博文章等，可以设置`Cache-control: no-cache`，使用协商缓存；
  3. 注意不要使用类似`Cache-control: max-age=600 must-revalidate `的方式，这会导致客户端缓存时间混乱，出现各种问题。

8. keep-alive
* HTTP1.0头字段`Collection: keep-alive`
* HTTP1.1默认就有长连接
长连接可以复用TCP连接，从而节省了时间，但改变不了HTTP是半双工协议的特征。

9. Array方法列举，哪些改变了array哪些没有
* 改变Array的方法：`push pop unshift shift splice reverse sort`
* 不改变Array的方法：`slice concat (filter reduce map)`
* 其他方法：`indexOf lastIndexOf forEach...`

10. 实现简单的promise, New, function.bind, Object.create, require模块加载器

11. 验证邮箱的正则表达式
`^[A-Za-z\d]+([-_.][A-Za-z\d]+)*@([A-Za-z\d]+[-.])+[A-Za-z\d]{2,4}$`

12. css动画animation、transition属性
* `animation: 'Bounce' 1000 ease-in 300 5 alternate`  
(name, time, time-func, delay, circle/infinite, reverse?/normal)
* `transition: 1000 swing 300`  
(property, time, time-func, delay)

13. 网页性能优化方法
* 宏观优化  
  1.**减少请求**(使用缓存、压缩资源、雪碧图、图片base64嵌入、图片懒加载等)  
  2.**js文件置于底部**
  ，防止阻塞其他元素的加载  
  3.**懒加载**，异步加载  
  4.将css内容放在顶部，**不使用@import**  
* Js优化  
  1.每次访问`HTMLCollection`元素都会重新获取一遍，可以将它转化为`Array`保存下来  
  2.`Reflow/Repaint`，频繁的Dom修改合并为一次操作  
  3.访问的作用域链越长，开销越大，对于操作次数非常多的情况，可以选择将作用域链较长的元素保存为局部变量  
  4.事件委托  

14. array-like Object有哪些？怎么转化成array？
* `arguments`函数参数, `arguments.callee`表示调用它的函数
* `HTMLCollectioin` 表示`Element node`的集合，通过`getElementsByName, getElementsByTagName, getElementsByClassName`获取，是动态的元素
* `NodeList`表示`node`集合，通过`.childNodes, querySelectorAll`等获取，是静态的元素。
* `NamedNodeMap`通过`Element.attributes`属性获取，包含所有的属性对象的集合

15. Array相关的问题
* 深拷贝数组的方法：
  1. 使用函数
  2. 使用JSON.parse(JSON.stringify(arr))
* 浅拷贝方法：
  1. [].slice.call(arr)
  2. [].concat.call(arr)
  3. b = [...a] 或 [...b] = a
* 数组同值
  1. Array(10).fill('a')
  2. Array.apply(null, {length: 10}).map(() => 'a')
* 数组转化:和浅拷贝类似
* 数组去重:
  1. for循环, forEach循环
  2. 利用Set [].from((new Set(arr)))
  3. 利用正则式
  4. 利用obj，类比桶排序
* obj类型检查：
  1. typeof
  2. instanceof 原型链相关
  3. constructor 需要原形和构造函数有联系
  4. {}.toString.call(obj) 返回 '[Object Object]'

16. cookie相关
* 读Cookie方法 `document.cookie`
* cookie的格式: `"xx=XX; yy=YY; ... ; zz=ZZ"`
* cookie最多4kB空间，保存用户的登录信息等
* cookie和session
  1. cookie存放在客户浏览器上，session存在服务器里
  2. 建议把登录信息等重要内容放在session，其他内容可以放在cookie
  3. cookie的形式是一个字符创，session是一个对象
  4. session不区分路径，访问一个网站的任意路径可访问相同的session；cookie有路径，不同路径中的cookie无法互相访问
* cookie的问题
  1. cookie空间太小
  2. 每次请求都要发送cookie，浪费带宽
  3. cookie无法跨域

17. localStorage和sessionStorage
* 大于5MB空间，可以存储较多信息
* webStorage是保存数据之用，sessionStorage在刷新/跳转到同源路径时不会消失，关闭浏览器或标签页才消失。
* 操作API(localStorage可换为sessionStorage)
```
localStorage.setItem(key, value);
localStorage.getItem(key);
localStorage.removeItem(key);
localStorage.clear();
localStorage.key(index);// 返回对应index的key值
```
注意：key和value全为字符串

18. 冒泡和捕获，事件流哪三个阶段？
* 事件：捕获阶段 -- 处理阶段 -- 冒泡阶段
* 事件委托利用了事件冒泡  
`var addEvent = addEventListener || attachEvent`  
`var target = e.target || e.srcElement;`

19. Css实现保持长宽比1:1
* 使用vw单位
* w30% + p-b100%
* grid网格随便搞

20. flex & grid重要的属性  
**Flex Base Styles**  
Container:  
`display: flex;`  
`flex-direction: column/row/column-reverse/row-reverse; `  
`justify-content: flex-end/flex-start/center/space-around/space-between/space-evenly`水平方向对齐  
align-items: flex-end...竖直方向对齐  
Item:  
`align-self: flex-end... `单个元素的垂直对齐方式  
**Normal Styles:**  
Container:  
`flex-wrap: wrap/wrap-reverse` 允许多行排布  
`align-content: space-evenly` 这个属性指的是有多列的flex子元素，怎么排列  
Item:  
`flex-grow: [Integer]` 这个属性指明拉伸(理解为)时元素拉伸多少倍，默认是1，设置为0时不会被拉伸，注意指的是拉伸比例而不是占据flex容器的多少  
`flex-shrink: 与flex-grow 相反`  
`flex-basis: [Num]px` 代替元素初始大小  
`flex: flex-grow flex-shrink flex-basis;` 简写形式  
**Grid Base Styles**  
Container:  
`grid-template-columns: 200px auto 200px;`  
`grid-template-rows: 100px 30px;`  
Item:  
`grid-column: 1 / 4;`  

21. 浏览器垃圾回收机制
* 引用计数，IE6-7应用的方法，容易内存泄漏
* 标记清除法，从根对象开始依次标记可达的对象，然后将其flag设为1，最后遍历所有元素，flag不为1的元素被删除

22. bootstrap中.row, .col-xs-5等的实现原理
* 响应式: `@media (min-width: 768/992/1200px)`依次写可以不写`max-width`之类的东西
* `.container`有两边15px的padding
* `.row`使用两边-15px的margin填充满container
* `.col-xs-5` 的实现：每种单元格类型均使用`float:left`，都是用左右`padding 15px`
针对n值的不同，设置width的百分比不同

23. 整理跨域相关的问题

**JSONP**  
页面中定义好方法，server中调用  
server中：
```
var qs = querystring.parse(req.url.split("?")[1]);
res.end(qs.callback + "(" + JSON.stringify(data) + ")");
```
应用格式：  
`<script src="http://127.0.0.1:3000/jsonp?callback=runMe"></script>`
* 只能使用GET方法
* 执行函数必须为全局函数

**CORS**
```
// 发送简易的ajax请求
var xmlhttp = new XMLHttpRequest();
xmlhttp.onreadystatechange = function () {
  if (xmlhttp.readystate === 4 && xmlhttp.status === 200) {
    // do something
  }
}
// 最后一个参数为false则表示同步请求
xmlhttp.open('GET', 'http://127.0.0.1:80', true);
xmlhttp.setRequestHeader('Origin', 'localhost');
xmlhttp.send(null);
服务器端
res.writeHead(200, {
  contentType: 'text/javascript;charset=UTF-8',
  'Access-Control-Allow-Origin': '*'
})
```
**window.name**
基本思路:
1. 将远程页面的`window.name`设置为一个待传递的字符串;
2. 在需要跨域的页面中引入远程页面`(<iframe>)`, 然后在脚本中将这个iframe的src替换成本地的空页面;
3. 使用`this.contentWindow.name`读取到数据。
eg:
```
<iframe src="http://127.0.0.1:3000/domainB" frameborder="1"></iframe>
// in script
var iframe = document.querySelector(iframe)[0];
var flag = 0;
iframe.onload = function () {
  if (flag === 0) {
    iframe.src = "./vain.html";
    flag = 1;
  } else {
    console.log(this.contentWindow.name);
    // 加上这一句之后就可以，刷新页面也有效
    document.body.removeChild(this);
  }
}
```

**PostMessage**
用于和iframe的通信
* 调用方使用
```
var targetOrigin = "*";
iframe.contentWindow.postMessage(input.value, targetOrigin);
```
* 服务端
```
window.addEventListener('message', function (e) {
  receive.innerHTML = e.data;
}, false)
```

Jquery的ajax请求实例
```
// post
button.click = function () {
  $.ajax({
    type: 'GET',
    url: 'service.php?number'= + $("#bt").val(),
    dataType: 'json',
    data: {
      name: 'Jelly'
    },
    success: function (data) {
      ...
    },
    error: function (jqXHR) {
      console.log(jqXHR.status);
    }
  })
}
```

23. websocket相关知识

HTML的限制：半双工、只能由客户端向服务器发送请求，如果要获取服务器状态则必须不断地轮询，浪费资源。  
websocket的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。
特点：建立在TCP协议之上，通过HTTP协议建立连接，无同源限制，可以发送文本和二进制数据。

24. 整理DOM操作
节点类型：
```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>A document</title>
  </head>
  <body>
    <!-- some comments -->
    <div>Document contents</div>
  </body>
</html>
```
* 节点都有`nodeType, nodeName, nodeValue, parentNode`等属性
* 常见的有：  

|node|nodeType|nodeName|nodeValue|parentNode|
|:--:|:--:|:--:|:--:|:--:|
|ELEMENT_NODE|1|`{tagName}`|null|父节点|
|ATTRIBUTE_NODE|2|`{name}`|`{value}`|null|
|TEXT_NODE|3|#test|`{value}`|父节点|
|COMMENT_NODE|8|#comment|`{value}`|父节点|
|DOCUMENT_NODE|9|#document|null|null|
|DOCUMENT_FRAGEMENT_NODE|11|#document-fragment|null|null|
|DOCUMENT_TYPE_NODE|10|doctype名|null|Document|

* 节点通常操作
属性：方便访问-同级的先后元素 / 子节点集合 / 第一个和最后一个子节点
`previousSibling / nextSibling
childNodes / firstChild / lastChild`

方法：
* 增：`appendChild(anode)`，注意如果anode已经存在，则相当于将其从原来的位置移动到新位置，返回anode
`insertBefore(insert_node, ref_node)`
* 删：`removeChild(anode)`
* 改：`replaceChild(new, old)`
* 复制：`cloneNode(BULL)`，BULL为true会复制所有子节点

* ELEMENT_NODE：
`className`属性
`attributes` Attr节点集合
`getAttribute(), setAttribute(), removeAttribute()`

* TEXT_NOD：
`document.createTextNode()`

25. DOM基本知识
* 访问/设置元素样式`element.style.backgroundColor/cssFloat...`  
* 删除样式`element.style.removeProperty(prop)`  
* 其他访问方式`ele.style.cssText, ele.style.getPropertyCSSValue(prop)可识别是否继承属性`  
* `document.defaultView.getComputedStyle(ele, null/':after')`求得计算属性,IE使用`ele.currentStyle`  
* DOM元素内在大小`ele.OffsetWidth/ele.OffsetHeight`  
* DOM元素内在盒子到父元素内边框的距离`ele.OffsetLeft/ele.OffsetTop`  
* 客户区大小表示padding + content,有两组:`ClientWidth/scrollWidth`  ,依据浏览器差异值较小的为内容区域大小，较大的为视口大小  
* 可以通过设置`scrollLeft/scrollTop的值`来滚动页面  
* 确定元素内在框位置: `ele.getBoundingClientRect()`返回含有`top,left,bottom,right`属性的矩形对象  

26. 延迟加载脚本async & defer
`<script async></script>`  
`<script defer></script>`  

27. 基本的快排
```
// 时间复杂度O(nlogn), 优化方式：1.三数字取中法优化主元；2.元素较少时使用插入排序作为替代
let arr = [];
for (let i = 0; i < 100; i++) {
  arr.push(Math.ceil(Math.random() * 2048));
}
quickSort(arr);
console.log(arr);

function quickSort(arr) {
  quick(arr, 0, arr.length-1);
}

function quick (arr, left, right) {
  // 注意边界条件判定
  if (left >= right) {
    return ;
  }

  let pivotIndex = Math.floor((right - left) / 2) + left;
  let pivot = arr[pivotIndex];

  // 开始时交换pivot和最右边的元素
  swap(pivotIndex, right);

  let i = left, j = right - 1;

  while (true) {
    while (arr[i] < pivot) {
      i++;
    }
    while (arr[j] > pivot) {
      j--;
    }
    if (i < j) {
      swap(i, j);
    } else {
      break;
    } 
  }

  swap(i, right);
  quick(arr, left, i - 1);
  quick(arr, i + 1, right);

  function swap (i, j) {
    // 同一元素则不用交换，节省资源
    if (i === j) {
      return ;
    }
    let tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
}
```
-------------

## 数据结构

-------------
> 线性数据结构  
>> 1. 链表翻转  
设置三个指针，分别指向new, old, tmp, 将old.next = new  
>> 2. 后缀表达式  
逆波兰式子，本质是栈的问题，比如`3*(2+5)/(3-1)` => `3 2 5 + * 3 1 - /`  
>> 3. 栈、队列基本操作和存储结构  
进栈、出栈、入队、出队，可以用链表或者数组存储  
>
> 树  
>> 1. 遍历方法，递归和非递归实现方法  
先序 递归或者用栈  
中序 递归或者用栈  
后序 递归或者用栈，栈中需要加一个域，表明是否被访问过  
层序 使用队列  
>> 2. 二叉树翻转  
和层序遍历一样使用队列就能实现  
>> 3. 二叉搜索树相关操作  
增删改查  
>> 4. AVL树  
单左 / 单右  
左右 = 右右 + 左左  
>> 5. 堆的操作  
堆是一棵完全二叉树(Complete Binary Tree)  
堆的建立：共O(n)时间，从下向上调整，最底层最多调整一次，最上层最多调整log(n)次  
堆的插入：从下向上调整，O(log(n))  
堆的删除：删除根节点，然后从上到下，把最后一个元素与下一层左右节点大的元素对比，O(log(n))  
>> 6. 并查集和哈夫曼树  
哈夫曼树：用于编码，不能存在歧义，数据存在叶节点上  
并查集：非二叉树，使用数组存储，根节点parent值为-1  
>
> 图
>> 1. DFS和BFS  
DFS使用递归或者栈可以实现  
BFS(breadth-first-search)使用队列  
>> 2. dijkstra和floyd算法  
dijkstra 用于计算单源最短路径 O(V^2+E), 堆优化后O(Elog(V))  
floyd 用于计算所有节点互相的最短路径 O(V^3)  
>> 3. Prim算法，kruskal  
用于最小生成树，思想都是贪心算法  
Prim类似dijkstra O(V^2)  
kruskal每次选取剩余E中最小的 O(Elog(E))  
>
> 散列  
散列适合不需要求最大最小值的数据存储，选择合适的h(key)，查找期望是O(1)  
散列是空间换时间的方法  
>> 1. 散列函数  
线性取余、数字分析、折叠、平方取中  
前三字符移位法、移位法，从末位开始计算 \c * 32^i,加和后取余。  
>> 2. 冲突处理  
. 开放定址法：线性探测(+i)、平方探测(±i^2)、双散列(i * h2())、再散列  
TableSize为4n + 3的素数，则平方探测可以探测整个table  
双散列 h2(key) = p - (key mod p)，p是素数    
装填因子α大于0.5 - 0.85时，扩大table，重新计算元素位置  
. 分离链接法：关键字都保存在同一单链表中  
>> 3. 性能分析  
装填因子α在0.5以下时各种冲突处理方式的平均查找次数基本相同  
开放定址法使用数组存储，效率高，但有聚集现象
>
> 排序算法  
>> 冒泡  
>> 插排   
>> 希尔 希尔序列（sedgewick序列可以优化至O(n^7/6))  
>> 选择（不稳定排序）  
>> 快排及优化 （三者取小、数目少时改用插排）  
>> 归并  
>> 堆排序 适用于要获取最小/大n个元素的场景，最坏时间复杂度也是O(nlogn)  
>> 桶排序  
>> 基数  
  
-------------

## 计算机网络

-------------

计算机网络相关总结
重点：每一层的相关设备、协议和算法

重点概念

拓扑：

    信道的分布方式，有总线型、星型、环形、树形和全联通/网状等
    互联网中主要用到总线型和星型来连接

OSI模型：

    Application 提供服务
    Presentation 数据的解释，解密加密等
    Session 保证会话连接
    Transport 端到端的连接
    Network 选择最优路径，点到点的连接
    Data Link 物理寻址，网络拓扑，错误提示，流控
    Physical 只负责传输2进制比特流

TCP/IP四层模型：

    Application
    Transport
    Internet
    Network Access

### 物理层
提供透明的比特流传输

带宽

    物理带宽vs数字带宽
    奈奎斯特定理 -- 在无噪声信道中，当频率为B，以每秒高于2B次的速率对线路采样是无意义的
    香农定理 -- 在有噪声信道中，频率为B Hz，信噪比为S/N时，最大传输速率为Blog2(1+S/N) bps
    噪声分贝值与信噪比的换算：db = 10log10(S/N)

**设备**


    引导性传输介质：主要有铜线和光纤  同轴电缆  双绞线
    非引导性传输介质：卫星、无线电等
    收发器(transceiver):是transmitter和reciver的简称，将一种形式的信号转化为另一种形式
    中继器(repeater)：信号再生，不可过滤
    集线器(hub)： 多端口的中继器，放大和再生信号，不可过滤

复用技术

    FDM(frequency division multiplexing) 正交FDM(orthogonal FDM)实现了复用，用在802.11，4G
    TDM(time division multiplexing) 用户轮流使用通道，用于telephone/cellular
    CDMA(code division multiple address)码分多址/扩展频谱  用于3G 码片正交

调制技术

    baseband transmission(基带传输)--直接将数据比特转化为信号
    passband transmission(通带传输)通过调节信号的振幅、相位和频率来传输信号
    基带传输方法：不归零逆转(比特时间内跳转为1),曼彻斯特编码,4B/5B跳转
    波特率是1s时间内传输的码元个数，也叫作码率
    比特率与波特率：C = Blog2(n) n表示电平数(允许的状态数)

### 数据链路层
为网络层提供良好的服务接口，保证数据传输的有效、可靠性，处理传输错误，进行流量控制

成帧方法
  
    字节填充的标志字节法：缺点是依赖于8位字节，而且容易在帧界造成混淆
    比特填充的标志比特法：以01111110作为帧开头，5个1补个0
    物理层编码违例法：采用冗余编码技术(使用调制技术中额外空闲的状态表示帧界)

纠错与检错

    海明距离是两个码字不同位的个数，如100001 和 111111 的海明距离为4
    海明距离与检错：海明距离d+1的编码能检出d位错误
    海明距离与纠错：海明距离为2d+1的编码，只能纠正d位差错
    纠一位错的海明码：冗余位个数r和数据位长度m之间满足 (m + r + 1 <= 2^r)
    检验位位于编号为2的整数次幂处，如1、2、4、8、16...位,进行的都是奇校验或偶校验
    * 循环冗余校验、互联网校验

**设备**
    

    * 网卡
    提供命名、成帧、Mac等功能
    * 交换机（网桥）
    存储转发  帧全部存储、进行校验之后转发，可靠性高但速度慢
    直通交换(贯穿)  读取到目的地址后直接转发，可靠性低
    无分片交换  读取64Byte即转发，消除了碎片帧的影响，提高了准确性

  
**基本协议**


    1. 无限制单工协议 
    2. 单工停-等协议
    解决了要求缓存空间无限大的假设
    解决方案：接收方收到帧后返回一个哑帧，此时发送下一帧
    3. 有噪声(错误)信道的单工协议
    采用了定时器防止丢帧死锁
    设置了一个定时器，如果在结束之前收到确认帧，则没有问题，否则重新发送帧
    对每一个帧确定了唯一序列号，防止重复处理帧

**滑窗协议**


    - 发送窗口(对应发送消息还未确认的帧的序号)
      接收窗口(对应着期望接受的帧的序号)

    - 信道利用率：k/(k+bR) k:每帧大小 b:传输速率 R:双程延迟时间
      位序列号只有0和1,信道利用率不高
      如果增加滑动窗口大小到W，则利用率变为W倍
      
    - 带宽延迟积：BD = 传输速率 * 单程延迟时间
      窗口值W <= 2*BD/k + 1

滑窗错误处理

    - 回退n帧
      发送窗口为n，接收窗口为1
      接收方策略：丢弃错帧，后续帧也丢弃
      发送方策略：将发送帧缓存起来，重发出错帧及之后的帧
    - 选择性重传
      发送方只重传差错帧
      接收方接收重传帧，按正确顺序提交给网络层

**MAC(media access control)子层**


    ALOHA协议、CSMA协议、CSMA/CD协议(以太网采用)
    - ALOHA工作原理：
    任何一个站点都在帧生成后立即发送，并通过信号的反馈检测信道，已确定是否发送成功
    如果发送失败，在随机延迟后再次发送
    冲突危险期为2个帧时(首尾相冲，浪费2个帧时)
    信道利用率 S 最大为18.6%(1/e/e),此时 G(网络负载) 为50%

    - 分隙ALOHA协议:
    分隙是将时间分为时隙(时间片)，帧的发送必须在时隙的开始
    冲突只会浪费一个帧时t
    信道利用率 S 最大为36.8%(1/e)，此时 G 为100%

    - CSMA协议(carrier sense multiple access)
    非持续式：等待随机事件重传
    1-持续：开始时保持持续侦听，介质空闲立即发送
    p-持续：开始时保持持续侦听，介质空闲以p概率发送

    - CSMA/CD协议
    1. 工作站同时接收自己的信号，如果和发送的不一致则表明冲突
    2. 冲突后立即停止发送，并发送一个简短的jam阻塞信号

**以太网**
    

    以太网包括了物理层和数据链路层
    使用CSMA/CD协议和二进制指数后退算法
    二进制指数后退算法：
    冲突后的等待时间：时隙为51.2μs，第i次冲突，等待的间隔从(0~2^i-1)*51.2μs中随机选择
    优化方法：把成功发送后的第一个时隙留给接收方，防止确认帧冲突
    使用交换机(switch)取代和集线器(hub)成为星型拓扑的中心节点
    干线上仍使用总线拓扑

帧结构

    先导字段 + 帧开始标记 + 目的地址 + 源地址 + 数据长度 + 数据 + 校验和
    62bit         xx        6Byte    6Byte    2Byte            4B
    802.3帧开始标记为11 数据长度46~1500B
    以太网帧开始标记为10 长度64字节，不足则填充

**二层交换**


    - 当一个帧到达网桥，它必须做出丢弃(discard)或者转发(forward)的决策
      决策是通过网桥内部一张MAC地址表查找得到的

    - 当一帧到达时，网桥启动如下算法：
      如果源Mac和目的Mac相同，丢弃这一帧
      如果源Mac和目的Mac不同，转发这一帧
      如果目的Mac未知，广播该帧
      每一帧到达，上述算法均执行一次

    - 网桥初始MAC地址表是空的
      通过泛洪算法将帧从除来的LAN的所有LAN转发出去
      逆向学习 学习帧来的那个LAN,将其写入MAC地址表
      无论何时,凡是往MAC表中输入记录,都打上时间戳
      到达帧的源地址在表中已有记录，则更新时间戳
      网桥周期性地扫描表，将超时的记录删除

**生成树协议(Spanning tree protocol)**


    一个LAN由多个网桥转发出去，可以应对单点故障的问题
    环路造成的问题广播风暴，所以用生成树协议生成逻辑上的无环路
    STP的运作原理：
    * 每个网络有一个根网桥
    * 每个网桥有一个根端口
    * 每个网段有一个指定端口
    * 非指定端口不被使用，但是会保持侦听，如果某个指定端口出现故障，非指定端口将被启用

VLAN

    隔离广播域和冲突域
    实现：基于端口(最常用)，基于三层协议，基于MAC地址

### 网络层
网络层需要封装源数据、找到目的机并找到一根好的路径(路由)

IPV4报头部分

|内容|大小|说明|
|:--:|:--:|:--:|
|协议版本|4bit|IPV4:0100 IPV6:0110|
|报头长度|4bit|以32bit为单位|
|服务类型|8bit|上层协议表明该分组的重要程度|
|数据报总长度|16bit|单位为字节|
|数据报标识号|16bit|当前分组的序列号，以便收方重组|
|标志/分片偏移|3bit/13bit|分组的分片号，以便收方重组|
|生存时间|8bit|Time To Live，一个计数器，TTL-1=0时分组被丢弃|
|用户协议|8bit|UDP:17 TCP:6|
|报头校验和|16bit|针对报头计算的互联网校验和，验证头部正确性|
|源点IP地址|32bit||
|目的点IP地址|32bit||
|数据报选项+填充|4byte的整数倍|不常用|

IPV6报头部分

|内容|大小|说明|
|:--:|:--:|:--:|
|协议版本|4bit|IPV4:0100 IPV6:0110|
|业务等级|8bit|分组的重要程度|
|流标记|20bit|流标签可用来标记特定流的报文|
|净荷长度|16bit||
|下一个头|8bit|扩展头，如果没有，为17/6 UDP/TCP|
|跳数限制|8bit||
|source|128bit|源IP|
|destination|128bit|目的IP|

**设备**
    
    - 路由器
    - 三层交换机

路由表

    - 路由器的动作：1.打开分组提取IP 2.查找路由表，AND操作 3.重新封装，转发
    - 路由表的由来：直连路由、静态路由、动态路由
    dos中输入 route print 可以看到主机路由表（静态）
    动态路由动态地建立、更新和维护的路由，适合大型的、经常变动的网络
    - 度量值：路径长度、可靠性、延迟、带宽、负载、通信价格

路由选择协议

    - 最优化原理：如果router J在I到K的最优路径上，则J到K的最优路径也同样在这条路径上

    - 沉落树(sink tree):从所有目的到源的最优路径形成的树，树根是源

    - DV 用于小型网络，维持D和V向量，D表示距离，V表示下一跳
    DV特点：简单，信息交流慢，收敛慢

    - RIP 路由信息协议是典型的DV协议，以跳数作为度量，(<15hop, 30s/exchange)
    RIP会形成路由环，可以通过水平分割、毒性逆转等

    - LS 用于大型网络
    发现 - 它的邻居节点们，了解它们的网络地址（发送HELLO，包含名字）
    设置 - 到它的每个邻居的成本度量（发送ECHO分组，通过应答间隔确定延迟）
    构造 - 一个分组，包含它所了解到的所有信息（周期性构造或者当特定事件(例如某个路由器down掉)发生时）
    发送 - 这个分组给所有其他的路由器（router记录下看到的源-序列号对）
    计算 - 到每个路由器的最短路径（使用dijkstra等算法求算最短路径）
    LS特点：每个路由器认识一致，收敛快，路由器计算和存储负担大

    - 单区域OSPF(open shortest path first)
    使用带宽作为度量值、应用广泛、无路由子环
    必须划分区域，所有子区域连接到骨干区域上
    通过选举DR和BDR将路由器之间通信的拓扑关系变为星型
    OSPF在每一条LSA中标记了生成者，克服了路由环

IP相关技术

    - 子网规划
    * 局域网不断增长，越来越难于管理，必须将其划分为子网
    * 一个网络被划分为几个部分(子网),但从外部看来是一个整体(体现在路由器的路由表例上,外部的路由器只对应一条路由)
    * 主路由器(边界路由器)维护一张子网掩码表，以向不同的分组转发

    - CIDR(classless interdomain routing)无类域间路由
    基本思想是分配IP地址时不再以类别分配，而是以地址块的形式(按需分配)
    根据需求分配网络位，避免地址浪费，缓解了IP地址枯竭的趋势

    - 路由聚合
    只有连续的块地址才能聚合成一个超网
    子网分配的逆过程

    - NAT(network address translation)私有IP和公有IP的转换
    - PAT(port address translation)将多个私有IP映射到一个公有IP的不同端口
    思路差不多，私网访问公网时转化为合法的global地址
    NAT能维持一个地址转换表，在数据到来时转发出去
    NAT转换了数据报文的端口地址
    NAT节约了公用IP数量，提供了灵活性和保密性，但增加了网络延迟，影响了部分协议和应用

    - ICMP(internet control message protocol)互联网控制消息协议
    ICMP用来向源(通常)报告IP分组的丢包、拥塞、延迟、抖动等
    ICMP也用于测试网络：ping命令，tracert命令

    - ARP(address resolution protocol)地址解析协议
    找到一个给定IP地址所对应的MAC地址
    ARP表 -- IP地址到MAC地址的映射表
    为了减少ARP请求的次数，每个设备都有ARP表，包括路由器
    dos 采用 arp -a 查看arp表信息; arp -d IP 删除记录; arp -s IP 添加记录

拥塞控制

    - 措施：增加资源或者降低负载
    抑制分组 路由器向源发一个抑制分组，源以一定百分比降低流量
    逐跳抑制分组 沿途路由均减少流量
    载荷脱落 直接丢弃分组
    随机早期检验random early detact 在队列长度超过阈值之前采取措施

    - 流量整形：调整数据传输平均速率，控制突发，较少拥塞
    漏桶算法 匀速，每一个tick允许固定数量发包、桶满丢弃分组
    令牌桶算法 允许加快到某种程度
      令牌桶中有令牌(token)，并以一定速率注入令牌
      分组要发送时必须取得令牌
      令牌桶允许积累令牌，最多可积累n个令牌(令牌桶容量)

### 传输层
传输层是整个TCP/IP协议的核心
传输层提供的是可靠的、高效的数据传输

UDP协议

    UDP是一个无连接的服务，在传输过程中无需建立连接
    很多C/S应用如DNS会发送一个UDP请求
    不提供差错检测和可靠传输，但是简洁高效
    头格式：源端口 + 目的端口 + 总长度(包含data) + 校验和 = 4Bytes

TCP数据段结构

    Source Port + Destination Port +
    Sequence Number +
    Acknowledgement Number +
    TCP header length + ... + URG + ACK + PSH + RST + SYN + FIN + 
    Window size +
    Checksum + Urgent Pointer +
    Options(0 or more 32bits) +
    Data

段头标记：

    URG: Urgent 紧急数据，即使窗口为0
    ACK: 确认号有效/无效
    PSH: push,不需缓存
    RST: 重置连接
    SYN: 连接建立
    FIN: 释放连接

TCP三次握手的建立

    Host1 SYN=1, ACK=0, seq=x
    Host2 SYN=1, ACK=1, seq=y, ack=x+1
    Host1 SYN=0, ACK=1, seq=x+1, ack=y+1

 TCP连接释放

    Host1 FIN=1
    Host2 ACK=1
    Host1收到后释放连接
    Host2 FIN=1
    Host1 ACK=1
    Host2收到后释放连接
    为了避免两军对垒问题，挥手需要四次
    TCP协议是全双工的

杀死半开放连接

    如果一定时间内没有TPDU到达，自动释放
    如果这样，传输实体在发送一个TPDU时必须启动一个定时器，如果定时器超期，将发送一个哑TPDU，以免被断掉

TCP流控和拥塞控制

    - TCP是全双工传输，通过window size进行流控
    发送方采用Nagle's algorithm, 尽量不发送数据含量小的数据段，缓存应用层的数据，达到一定量再发送。
    接收方采用Clark's algorithm,不请求对方发送短数据段，延迟窗口变更信息，使接收缓冲区足够大。

    - 网络层也可以管理拥塞，但大多数繁重的任务由TCP完成，解决方案为减慢数据率
    接收者窗口反映目前窗口的容量，容易控制
    拥塞窗口反映目前网络容量，难于控制
    采用慢启动算法，速率先指数增长，到达阈值的一半以上后线性增大

TCP和UDP

    TCP
    可靠的传输方式
    提供较好的流控
    可让应用程序简单化，程序员不必进行错误检查、修正工作

    UDP 
    降低对计算机资源的需求
    本身提供了数据完整性的检测
    传递的并非关键性数据
    一对多方式，必须使用UDP

